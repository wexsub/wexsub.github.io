<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Wexsub&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Wexsub&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Wexsub&#39;s blog">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Wexsub's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wexsub's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/16/the的念法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wexsub">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wexsub's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/16/the的念法/" class="post-title-link" itemprop="url">the的念法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-16 11:28:21 / 修改时间：11:31:05" itemprop="dateCreated datePublished" datetime="2020-02-16T11:28:21+08:00">2020-02-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/English/" itemprop="url" rel="index">
                    <span itemprop="name">English</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>the</code>在不同情况下有不同读音</p>
<p>1、the后面的单词的音标是以元音音素开头的，the读作<strong>[ði]</strong>。</p>
<p>例如：I can’t see the importance of the news.我看不出来这条新闻的重要性。</p>
<p>2、the后面单词的音标是以辅音音素开头的，the读作<strong>[ðə]</strong>。</p>
<p>例如：The man over there is my brother.站在那里的男人是我哥哥。</p>
<p>其中，元音 <strong>/α:/、/כ/、/כ:/、/u/、/u:/、/Λ/、/∂/、/∂:/</strong>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/15/official-53/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wexsub">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wexsub's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/15/official-53/" class="post-title-link" itemprop="url">Self-Driving Cars Probably Won't Boost Commuter Productivity</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-15 16:16:35" itemprop="dateCreated datePublished" datetime="2020-02-15T16:16:35+08:00">2020-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-26 22:54:53" itemprop="dateModified" datetime="2020-02-26T22:54:53+08:00">2020-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/English/" itemprop="url" rel="index">
                    <span itemprop="name">English</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Self-Driving-Cars-Probably-Won’t-Boost-Commuter-Productivity"><a href="#Self-Driving-Cars-Probably-Won’t-Boost-Commuter-Productivity" class="headerlink" title="Self-Driving Cars Probably Won’t Boost Commuter Productivity"></a>Self-Driving Cars Probably Won’t Boost Commuter Productivity</h1><h2 id="Vocabulary"><a href="#Vocabulary" class="headerlink" title="Vocabulary:"></a>Vocabulary:</h2><p>1.sicientific</p>
<p>2.advocate</p>
<p>3.tout</p>
<p>4.congestion</p>
<p>5.allege(alleged)</p>
<p>6.productivity</p>
<p>7.newfound</p>
<p>8.whittle  (whittle down)</p>
<h2 id="expressions"><a href="#expressions" class="headerlink" title="expressions:"></a>expressions:</h2><p>1.another alleged value of … is …</p>
<p>另一个说法是</p>
<p>e.g. <strong>Another alleged value of being a passenger rather than a driver is more productivity-you could work rather than concentrate on driving.</strong></p>
<h2 id="sentences"><a href="#sentences" class="headerlink" title="sentences:"></a>sentences:</h2><p>1.Got a minute?  有一分钟时间吗？</p>
<p>2.But most people might not spend their newfound free time in self-driving cars whittling down their to-do lists. </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/13/linux下的解压缩/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wexsub">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wexsub's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/13/linux下的解压缩/" class="post-title-link" itemprop="url">linux下的解压缩</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-13 19:55:32 / 修改时间：20:14:01" itemprop="dateCreated datePublished" datetime="2020-02-13T19:55:32+08:00">2020-02-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="linux下解压缩命令小结"><a href="#linux下解压缩命令小结" class="headerlink" title="linux下解压缩命令小结"></a>linux下解压缩命令小结</h1><h2 id="综述："><a href="#综述：" class="headerlink" title="综述："></a>综述：</h2><p>linux下解压缩工具包括tar、gzip、gunzip、bzip2、bunzip2、compress 、uncompress、 zip、 unzip、rar、unrar等，压缩文件共有.tar、.gz 、.tar.gz、.tgz、.bz2、.tar.bz2、.Z、. tar.Z、.zip、.rar这10中格式。</p>
<h2 id="tar："><a href="#tar：" class="headerlink" title="tar："></a>tar：</h2><p>Linux下最常用的打包程序就是tar了，使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩了，所以首先就来讲讲tar命令的基本用法：</p>
<p>tar命令的选项有很多(用<code>man tar</code>可以查看到)，但常用的就那么几个选项，下面来举例说明一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cf all.tar *.jpg</span><br></pre></td></tr></table></figure>
<p>这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包 ，-f指定包的文件名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -rf all.tar *.gif</span><br></pre></td></tr></table></figure>
<p>这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -uf all.tar logo.gif</span><br></pre></td></tr></table></figure>
<p>这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -tf all.tar</span><br></pre></td></tr></table></figure>
<p>这条命令是列出all.tar包中所有文件，-t是列出文件的意思</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -xf all.tar</span><br></pre></td></tr></table></figure>
<p>这条命令是解出all.tar包中所有文件，-x是解开的意思</p>
<p>以上就是tar的最基本的用法。为了方便用户在打包解包的同时可以压缩或解压文件，tar提供了一种特殊的功能。这就是tar可以在打包或解包的同时调用其它的压缩程序，比如调用gzip、bzip2等。</p>
<h3 id="1-tar调用gzip"><a href="#1-tar调用gzip" class="headerlink" title="1) tar调用gzip"></a>1) tar调用gzip</h3><p>gzip是GNU组织开发的一个压缩程序，<code>.gz</code>结尾的文件就是gzip压缩的结果。与gzip 相对的解压程序是gunzip。tar中使用-z这个参数来调用gzip。下面来举例说明一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czf all.tar.gz *.jpg</span><br></pre></td></tr></table></figure>
<p>这条命令是将所有.jpg的文件打成一个tar包，并且将其用gzip压缩，生成一个gzip压缩过的包，包名为all.tar.gz</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf all.tar.gz</span><br></pre></td></tr></table></figure>
<p>这条命令是将上面产生的包解开。</p>
<h3 id="2-tar调用bzip2"><a href="#2-tar调用bzip2" class="headerlink" title="2) tar调用bzip2"></a>2) tar调用bzip2</h3><p>bzip2是一个压缩能力更强的压缩程序，.bz2结尾的文件就是bzip2压缩的结果。</p>
<p>与bzip2相对的解压程序是bunzip2。tar中使用-j这个参数来调用gzip。下面来举例说明一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cjf all.tar.bz2 *.jpg</span><br></pre></td></tr></table></figure>
<p>这条命令是将所有.jpg的文件打成一个tar包，并且将其用bzip2压缩，生成一个bzip2压缩过的包，包名为all.tar.bz2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xjf all.tar.bz2</span><br></pre></td></tr></table></figure>
<p>这条命令是将上面产生的包解开。</p>
<p><strong>3)tar调用compress</strong> </p>
<p>compress也是一个压缩程序，但是好象使用compress的人不如gzip和bzip2的人多。.Z结尾的文件就是bzip2压缩的结果。与 compress相对的解压程序是uncompress。tar中使用-Z这个参数来调用compress。下面来举例说明一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cZf all.tar.Z *.jpg</span><br></pre></td></tr></table></figure>
<p>这条命令是将所有.jpg的文件打成一个tar包，并且将其用compress压缩，生成一个uncompress压缩过的包，包名为all.tar.Z</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xZf all.tar.Z</span><br></pre></td></tr></table></figure>
<p>这条命令是将上面产生的包解开</p>
<p><strong>有了上面的知识，我们可以解开多种压缩文件了，下面对于tar系列的压缩文件作一个小结</strong>：</p>
<p>1)对于.tar结尾的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf all.tar</span><br></pre></td></tr></table></figure>
<p>2)对于.gz结尾的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gzip -d all.gz</span><br><span class="line"></span><br><span class="line">gunzip all.gz</span><br></pre></td></tr></table></figure>
<p>3)对于.tgz或.tar.gz结尾的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf all.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xzf all.tgz</span><br></pre></td></tr></table></figure>
<p>4)对于.bz2结尾的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bzip2 -d all.bz2</span><br><span class="line"></span><br><span class="line">bunzip2 all.bz2</span><br></pre></td></tr></table></figure>
<p>5)对于tar.bz2结尾的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xjf all.tar.bz2</span><br></pre></td></tr></table></figure>
<p>6)对于.Z结尾的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uncompress all.Z</span><br></pre></td></tr></table></figure>
<p>7)对于.tar.Z结尾的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xZf all.tar.z</span><br></pre></td></tr></table></figure>
<p>另外对于Window下的常见压缩文件.zip和.rar，Linux也有相应的方法来解压它们：</p>
<h2 id="对于-zip"><a href="#对于-zip" class="headerlink" title="对于.zip"></a>对于.zip</h2><p>linux下提供了zip和unzip程序，zip是压缩程序，unzip是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip all.zip *.jpg</span><br></pre></td></tr></table></figure>
<p>这条命令是将所有.jpg的文件压缩成一个zip包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip all.zip</span><br></pre></td></tr></table></figure>
<p>这条命令是将all.zip中的所有文件解压出来</p>
<h2 id="对于-rar"><a href="#对于-rar" class="headerlink" title="对于.rar"></a>对于.rar</h2><p>要在linux下处理.rar文件，需要安装RAR for Linux，可以从网上下载，但要记住，RAR for Linux 不是免费的；可从<a href="http://www.rarsoft.com/download.htm下载RARfor" target="_blank" rel="noopener">http://www.rarsoft.com/download.htm下载RARfor</a> Linux 3.2.<br> 0，然后安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xzpvf rarlinux-3.2.0.tar.gz  </span><br><span class="line">cd rar </span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>这样就安装好了，安装后就有了rar和unrar这两个程序，rar是压缩程序，unrar 是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rar a all *.jpg</span><br></pre></td></tr></table></figure>
<p>这条命令是将所有.jpg的文件压缩成一个rar包，名为all.rar，该程序会将.rar 扩展名将自动附加到包名后。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># unrar e all.rar</span><br></pre></td></tr></table></figure>
<p>这条命令是将all.rar中的所有文件解压出来</p>
<h2 id="以下补充"><a href="#以下补充" class="headerlink" title="以下补充"></a>以下补充</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c: 建立压缩档案 </span><br><span class="line">-x：解压 </span><br><span class="line">-t：查看内容 </span><br><span class="line">-r：向压缩归档文件末尾追加文件 </span><br><span class="line">-u：更新原压缩包中的文件</span><br></pre></td></tr></table></figure>
<p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-z：有gzip属性的 </span><br><span class="line">-j：有bz2属性的 </span><br><span class="line">-Z：有compress属性的 </span><br><span class="line">-v：显示所有过程 </span><br><span class="line">-O：将文件解开到标准输出</span><br></pre></td></tr></table></figure>
<p>下面的参数-f是必须的</p>
<p>-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 </p>
<p><strong>压缩 
</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar –cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg </span><br><span class="line">tar –czf jpg.tar.gz *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz </span><br><span class="line">tar –cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2 </span><br><span class="line">tar –cZf jpg.tar.Z *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z </span><br><span class="line">rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux </span><br><span class="line">zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux</span><br></pre></td></tr></table></figure>
<p><strong>解压</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar –xvf file.tar //解压 tar包 </span><br><span class="line">tar -xzvf file.tar.gz //解压tar.gz </span><br><span class="line">tar -xjvf file.tar.bz2 //解压 tar.bz2 </span><br><span class="line">tar –xZvf file.tar.Z //解压tar.Z </span><br><span class="line">unrar e file.rar //解压rar </span><br><span class="line">unzip file.zip //解压zip</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、.tar 用 tar –xvf 解压 </span><br><span class="line">2、.gz 用 gzip -d或者gunzip 解压 </span><br><span class="line">3、.tar.gz和*.tgz 用 tar –xzf 解压 </span><br><span class="line">4、.bz2 用 bzip2 -d或者用bunzip2 解压 </span><br><span class="line">5、.tar.bz2用tar –xjf 解压 </span><br><span class="line">6、.Z 用 uncompress 解压 </span><br><span class="line">7、.tar.Z 用tar –xZf 解压 </span><br><span class="line">8、.rar 用 unrar e解压 </span><br><span class="line">9、.zip 用 unzip 解压</span><br></pre></td></tr></table></figure>
<h2 id="参考（抄）链接："><a href="#参考（抄）链接：" class="headerlink" title="参考（抄）链接："></a>参考（抄）链接：</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/13/wget/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wexsub">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wexsub's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/13/wget/" class="post-title-link" itemprop="url">wget</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-13 19:31:28 / 修改时间：20:49:34" itemprop="dateCreated datePublished" datetime="2020-02-13T19:31:28+08:00">2020-02-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h1><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>wget命令**用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。</p>
<h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget(选项)(参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-a&lt;日志文件&gt;：在指定的日志文件中记录资料的执行过程；</span><br><span class="line">-A&lt;后缀名&gt;：指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；</span><br><span class="line">-b：进行后台的方式运行wget；</span><br><span class="line">-B&lt;连接地址&gt;：设置参考的连接地址的基地地址；</span><br><span class="line">-c：继续执行上次终端的任务；</span><br><span class="line">-C&lt;标志&gt;：设置服务器数据块功能标志on为激活，off为关闭，默认值为on；</span><br><span class="line">-d：调试模式运行指令；</span><br><span class="line">-D&lt;域名列表&gt;：设置顺着的域名列表，域名之间用“，”分隔；</span><br><span class="line">-e&lt;指令&gt;：作为文件“.wgetrc”中的一部分执行指定的指令；</span><br><span class="line">-h：显示指令帮助信息；</span><br><span class="line">-i&lt;文件&gt;：从指定文件获取要下载的URL地址；</span><br><span class="line">-l&lt;目录列表&gt;：设置顺着的目录列表，多个目录用“，”分隔；</span><br><span class="line">-L：仅顺着关联的连接；</span><br><span class="line">-r：递归下载方式；</span><br><span class="line">-nc：文件存在时，下载文件不覆盖原有文件；</span><br><span class="line">-nv：下载时只显示更新和出错信息，不显示指令的详细执行过程；</span><br><span class="line">-o: 指定文件名；</span><br><span class="line">-q：不显示指令执行过程；</span><br><span class="line">-nh：不查询主机名称；</span><br><span class="line">-v：显示详细执行过程；</span><br><span class="line">-V：显示版本信息；</span><br><span class="line">--passive-ftp：使用被动模式PASV连接FTP服务器；</span><br><span class="line">--follow-ftp：从HTML文件中下载FTP连接文件。</span><br><span class="line">--limit-rate=：限速；</span><br></pre></td></tr></table></figure>
<h2 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL： 下载指定的URL地址</span><br></pre></td></tr></table></figure>
<h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><h3 id="o（下载并以不同的文件名保存）："><a href="#o（下载并以不同的文件名保存）：" class="headerlink" title="-o（下载并以不同的文件名保存）："></a>-o（下载并以不同的文件名保存）：</h3><p>一般来说，wget会以最后一个符合<code>/</code>的后面的字符来命令，对于<strong>动态链接</strong>的下载通常文件名会不正确。</p>
<p>比如说下面的例子会下载一个文件并以名称<code>download.aspx?id=1080</code>保存:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.***.com/download?id=1</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，我们可以使用参数<code>-O</code>来指定一个文件名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O ***.zip http://www.***.com/download?id=1</span><br></pre></td></tr></table></figure>
<h3 id="—limit-rate-（限速）："><a href="#—limit-rate-（限速）：" class="headerlink" title="—limit-rate=（限速）："></a>—limit-rate=（限速）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --limit-rate=300k http://www.***.com/testfile.zip</span><br></pre></td></tr></table></figure>
<p>当你执行wget的时候，它默认会占用全部可能的宽带下载。但是当你准备下载一个大文件，而你还需要下载其它文件时就有必要限速了。</p>
<h3 id="c（断点续传）："><a href="#c（断点续传）：" class="headerlink" title="-c（断点续传）："></a>-c（断点续传）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c http://www.linuxde.net/testfile.zip</span><br></pre></td></tr></table></figure>
<p>使用<code>wget -c</code>重新启动下载中断的文件，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用<code>-c</code>参数。</p>
<h3 id="i（下载多个文件）："><a href="#i（下载多个文件）：" class="headerlink" title="-i（下载多个文件）："></a>-i（下载多个文件）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -i filelist.txt</span><br></pre></td></tr></table></figure>
<p>首先，保存一份下载链接文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; filelist.txt</span><br><span class="line">url1</span><br><span class="line">url2</span><br><span class="line">url3</span><br><span class="line">url4</span><br></pre></td></tr></table></figure>
<p>接着使用这个文件和参数<code>-i</code>下载。</p>
<h3 id="镜像网站："><a href="#镜像网站：" class="headerlink" title="镜像网站："></a>镜像网站：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --mirror -p --convert-links -P ./LOCAL URL</span><br></pre></td></tr></table></figure>
<p> 下载整个网站到本地。</p>
<ul>
<li><code>--miror</code>开户镜像下载。</li>
<li><code>-p</code>下载所有为了html页面显示正常的文件。</li>
<li><code>--convert-links</code>下载后，转换成本地的链接。</li>
<li><code>-P ./LOCAL</code>保存所有文件和目录到本地指定目录。</li>
</ul>
<h3 id="过滤指定格式下载："><a href="#过滤指定格式下载：" class="headerlink" title="过滤指定格式下载："></a>过滤指定格式下载：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --reject=gif ur</span><br></pre></td></tr></table></figure>
<p> 下载一个网站，但你不希望下载图片，可以使用这条命令。</p>
<h2 id="参考（抄）网址："><a href="#参考（抄）网址：" class="headerlink" title="参考（抄）网址："></a>参考（抄）网址：</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/两种计算模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wexsub">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wexsub's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/两种计算模型/" class="post-title-link" itemprop="url">两种计算模型</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-30 02:53:08 / 修改时间：03:38:19" itemprop="dateCreated datePublished" datetime="2020-01-30T02:53:08+08:00">2020-01-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="综述："><a href="#综述：" class="headerlink" title="综述："></a>综述：</h1><p>​    两种计算模型（图灵机和ram）的作用都是比较与评判算法的效率。</p>
<p>​    话说好像没啥好写的，就放了些图片。图片来自清华大学数据结构慕课（Junhui Deng）的讲义。</p>
<h1 id="1-图灵机"><a href="#1-图灵机" class="headerlink" title="1.图灵机"></a>1.图灵机</h1><p><img src="https://s2.ax1x.com/2020/01/30/1lMbW9.png" alt="图灵机1"></p>
<p><img src="https://s2.ax1x.com/2020/01/30/1lMOQ1.png" alt="图灵机2"></p>
<p><img src="https://s2.ax1x.com/2020/01/30/1lMjL6.png" alt="图灵机3"></p>
<p>其中<code>(&lt;, 1; 0, L, &lt;)</code>之类的式子，与其说是一个步骤，不如说是一个法则，一种if法则。</p>
<h1 id="2-ram-random-access-machine"><a href="#2-ram-random-access-machine" class="headerlink" title="2.ram(random access machine)"></a>2.ram(random access machine)</h1><p><strong>注意，ram只有加减的操作。</strong></p>
<p><img src="https://s2.ax1x.com/2020/01/30/1lMXsx.png" alt="ram1"></p>
<p><img src="https://s2.ax1x.com/2020/01/30/1lM7i4.png" alt="ram2"></p>
<p><img src="https://s2.ax1x.com/2020/01/30/1l3FSJ.png" alt="ram3"></p>
<p><img src="https://s2.ax1x.com/2020/01/30/1lMqzR.png" alt></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/26/离散数学学习笔记1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wexsub">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wexsub's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/26/离散数学学习笔记1/" class="post-title-link" itemprop="url">离散数学学习笔记1</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-26 01:41:20 / 修改时间：04:47:26" itemprop="dateCreated datePublished" datetime="2020-01-26T01:41:20+08:00">2020-01-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-条件语句"><a href="#1-条件语句" class="headerlink" title="1.条件语句"></a>1.条件语句</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><script type="math/tex; mode=display">
令p和q为命题。条件语句\ p\rightarrow q\ 是命题“如果p，则q”。\\ 当p为真而q为假时，条件语句\ p\rightarrow q\ 为假，否则为真。</script><p>​    容易混淆的语句：</p>
<script type="math/tex; mode=display">
“p仅当q”和“q除非\neg p”\\ 请记住“p仅当q”表达了与“如果p, 则q”同样的意思， 注意“p仅当q”说的是当q不为真时p不能为真。\\ 也就是说，如果p为真但q为假，则这个语句为假。\\ 当p为假时，q可以为真也可以为假，因为语句并没有谈及q的真值。\\ 要小心不要用“q仅当p”来表达p\rightarrow q, 因为这是错误的。\\ 要明白这一点，请注意当p和q取不同的真值时，“q仅当p”和p\rightarrow q的真值是不
同的。\\ 请记住“q除非\neg p“表达了和p\rightarrow q条件语句一样的意思，\\ 注意“q除非\neg p”的意思是如果\neg p是假的，则q必是真的。\\ 也就是说，当p为真，而q为假时，语句“q除非\neg p”是假的，否则是真的。\\ 因此， “q除非\neg p”与p\rightarrow q总是具有相同的真值。</script><h1 id="2-重要的逻辑等价式"><a href="#2-重要的逻辑等价式" class="headerlink" title="2.重要的逻辑等价式"></a>2.重要的逻辑等价式</h1><script type="math/tex; mode=display">
结合律：\\ 
(p\vee q)\vee r\equiv p\vee(q\vee r)\\
(p\wedge q)\wedge r\equiv p\wedge(q\wedge r)\\
分配律(良定义)：\\
p\vee(q\wedge r)\equiv (p\vee q)\wedge(p\vee r)\\
p\wedge(q\vee r)\equiv (p\wedge q)\vee(p\wedge r)\\
徳·摩根律：\\
\neg(p\wedge q)\equiv \neg p \vee \neg q\\
\neg(p\vee q)\equiv \neg p \wedge \neg q\\
\neg (\bigvee_{j=1}^{n}p_{j})\equiv\bigwedge_{j=1}^{n}\neg p_{j}\\
\neg (\bigwedge_{j=1}^{n}p_{j})\equiv\bigvee_{j=1}^{n}\neg p_{j}\\
吸收律：\\
p\wedge (p \vee q)\equiv p\\
p\vee (p \wedge q)\equiv p</script><h2 id="条件命题的逻辑等价式："><a href="#条件命题的逻辑等价式：" class="headerlink" title="条件命题的逻辑等价式："></a>条件命题的逻辑等价式：</h2><script type="math/tex; mode=display">
p\rightarrow q\equiv\neg p\vee q\\
p\rightarrow q\equiv\neg q\rightarrow\neg p\\
p\vee q\equiv \neg p\rightarrow q\\
p\wedge q\equiv \neg(p\rightarrow \neg q)\\
\neg(p\rightarrow q)\equiv p\wedge\neg q\\
(p\rightarrow q)\wedge(p\rightarrow r)\equiv p\rightarrow(q\wedge r)\\
(p\rightarrow r)\wedge(q\rightarrow r)\equiv (p\vee q)\rightarrow r\\
(p\rightarrow q)\vee(p\rightarrow r)\equiv p\rightarrow(q\vee r)\\
(p\rightarrow r)\vee(q\rightarrow r)\equiv (p\wedge q)\rightarrow r</script><h2 id="双条件命题的逻辑等价式："><a href="#双条件命题的逻辑等价式：" class="headerlink" title="双条件命题的逻辑等价式："></a>双条件命题的逻辑等价式：</h2><script type="math/tex; mode=display">
p\leftrightarrow q\equiv(p\to q)\wedge(q\to p)\\
p\leftrightarrow q\equiv\neg p\leftrightarrow\neg q\\
p\leftrightarrow q\equiv(p\wedge q)\vee(\neg p\wedge \neg q)\\
\neg(p\leftrightarrow q)\equiv p\leftrightarrow\neg q</script><p>​    命题逻辑学深了的话，会很难，但也很有用。后面的数独解法在过完算法一章后，看能不能写个报告，早知道大作业做这个了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/18/pwntools笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wexsub">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wexsub's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/18/pwntools笔记/" class="post-title-link" itemprop="url">pwntools笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-18 12:31:49 / 修改时间：12:37:32" itemprop="dateCreated datePublished" datetime="2020-01-18T12:31:49+08:00">2020-01-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网安/" itemprop="url" rel="index">
                    <span itemprop="name">网安</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/18/bugku-new-刷题笔记1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wexsub">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wexsub's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/18/bugku-new-刷题笔记1/" class="post-title-link" itemprop="url">bugku(new)刷题笔记1</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-18 11:44:16" itemprop="dateCreated datePublished" datetime="2020-01-18T11:44:16+08:00">2020-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-20 13:50:19" itemprop="dateModified" datetime="2020-01-20T13:50:19+08:00">2020-01-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网安/" itemprop="url" rel="index">
                    <span itemprop="name">网安</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="题目网址："><a href="#题目网址：" class="headerlink" title="题目网址："></a>题目网址：</h5><p><a href="https://new.bugku.com/challenges" target="_blank" rel="noopener">newbugku</a></p>
<h5 id="用户id"><a href="#用户id" class="headerlink" title="用户id:"></a>用户id:</h5><p>centuryplant</p>
<h1 id="misc-0和1的故事"><a href="#misc-0和1的故事" class="headerlink" title="(misc) 0和1的故事"></a>(misc) 0和1的故事</h1><p>下载下来的文件是一个压缩包，解压到最后是一个文本文件：<code>flag{}.txt</code>,打开文件发现只有一行，显示的是<code>Flag_is_not_here</code>。</p>
<p>用notepad打开，发现有很多空行。</p>
<p>根据提示，将空格替换成0，替换后发现还有空格，应该是Tab。把剩下的<code>\t</code>用1替换。得到一串二进制，再转换成16进制，就是flag。</p>
<h1 id="pwn-最简单的pwn"><a href="#pwn-最简单的pwn" class="headerlink" title="(pwn)最简单的pwn"></a>(pwn)最简单的pwn</h1><p>直接<code>nc</code> 连接，然后<code>cat</code>得到flag？</p>
<p>我连接的时候显示<code>connection refused</code>，没法，直接抄了flag上去。</p>
<h1 id="web-web1"><a href="#web-web1" class="headerlink" title="(web)web1"></a>(web)web1</h1><p>两个函数。</p>
<p>第一个函数是<code>file_get_contents()</code>，作用应该是从一个<code>url</code>返回网站的数据，但<code>$b</code>只是一串没有意义的字符，所以应该返回空或者报错。</p>
<p>第二个函数是<code>trim()</code>，作用是去除字符首尾的空白字符。</p>
<p>本地试了一下，在本地php版本下file_get_contents()已经返回空（不是<code>NULL</code>）了，所以加参数，使网页url构造为<code>http://123.206.31.85:10001/?a=</code>即得flag。</p>
<h1 id="web-web26"><a href="#web-web26" class="headerlink" title="(web)web26"></a>(web)web26</h1><p>这道题有点怪。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$num=$_GET[&apos;num&apos;]; </span><br><span class="line">$str=$_GET[&apos;str&apos;]; </span><br><span class="line">show_source(__FILE__); </span><br><span class="line">if (isset($num)&amp;&amp;isset($str)) &#123; </span><br><span class="line">    if (preg_match(&apos;/\d+/sD&apos;,$str)) &#123; </span><br><span class="line">        echo &quot;vagetable hhhh&quot;; </span><br><span class="line">        exit(); </span><br><span class="line">    &#125; </span><br><span class="line">    $result=is_numeric($num) and is_numeric($str); </span><br><span class="line">    if ($result) &#123; </span><br><span class="line">        include &quot;flag.php&quot;; </span><br><span class="line">        echo &quot;$flag&quot;; </span><br><span class="line">    &#125; </span><br><span class="line">    else&#123; </span><br><span class="line">        echo &quot;vagetablessssss&quot;; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>重点在于<code>is_numeric()</code>函数的否定返回是空，而不是0.</p>
<p>我理解的题意是，<code>str</code>是一个是数字（字符），但不能出现数字。</p>
<p>但实际上因为上面那个原因，<code>and</code> 好像没有作用一样。只要让<code>str</code>是一个字符就行了。-_-</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/14/c++函数重载的一些讨论/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wexsub">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wexsub's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/14/c++函数重载的一些讨论/" class="post-title-link" itemprop="url">关于运算符重载的一些简单细节讨论</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-14 06:52:46" itemprop="dateCreated datePublished" datetime="2020-01-14T06:52:46+08:00">2020-01-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-18 11:42:41" itemprop="dateModified" datetime="2020-01-18T11:42:41+08:00">2020-01-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-语法/" itemprop="url" rel="index">
                    <span itemprop="name">c++语法</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="关于运算符重载的一些简单细节讨论"><a href="#关于运算符重载的一些简单细节讨论" class="headerlink" title="关于运算符重载的一些简单细节讨论"></a>关于运算符重载的一些简单细节讨论</h1><h2 id="1-运算符重载的本质仍是函数重载"><a href="#1-运算符重载的本质仍是函数重载" class="headerlink" title="1. 运算符重载的本质仍是函数重载"></a>1. 运算符重载的本质仍是函数重载</h2><p>​    在学习的过程中，曾多次强调运算符重载的本质是函数重载，更具体地说，<strong>重载的运算符是可以用中序语法调用的成员函数或友元函数</strong>。使用中序语法，代码会更直观。但在某些情况下，使用成员函数原来的形式（<code>operator[运算符]</code>）或许更加容易理解。</p>
<p>​    作为对比，先是一些运算符重载的例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 《c++覆辙录》：常见错误23</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> T <span class="keyword">operator</span>+(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;); </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> T&amp;);</span><br><span class="line">    T <span class="keyword">operator</span>-();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T a,b;</span><br><span class="line">a=b;</span><br><span class="line">a.<span class="keyword">operator</span>=(b);</span><br></pre></td></tr></table></figure>
<p>​    其中<code>a=b</code>和<code>a.operator=(b)</code>等价，而编译器在编译过程中也会将前者替换为后者，但我们直接用后者也是可以的。一般情况下，我们会选择第一种写法，也就是中序写法。</p>
<p>​    在另外的一些情况下，可能选择后者是一种更好的选择。一个例子是派生类的复制赋值运算符调用基类的复制赋值运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//《c++覆辙录》：常见错误23 （改）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp;)&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> B&amp;);</span><br><span class="line">    B(<span class="keyword">int</span> k=<span class="number">0</span>):c(k)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B &amp; B::<span class="keyword">operator</span>=(<span class="keyword">const</span> B&amp;b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;b != <span class="keyword">this</span>)&#123;</span><br><span class="line">        A::<span class="keyword">operator</span>=(b);</span><br><span class="line">        (*<span class="keyword">static_cast</span>&lt;A*&gt;(<span class="keyword">this</span>)) = b;</span><br><span class="line">        c = b.c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    可以明显地看到，此处调用基类A的复制赋值运算符采用成员函数的形式更为清晰，也更好写。如果要采用中序写法，要先进行类型转换，再复制赋值，即<code>(*static_cast&lt;A*&gt;(this))=b</code>的形式，会让读代码的人不易理解。    </p>
<p>​    但令人迷惑的是中序记法与成员函数有<strong>一点本质的不同</strong>，这点也需要记一下。使用中序记法编译时会搜索包括成员函数和非成员函数的对应运算符重载，但使用成员函数记法编译时只会搜索成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//《c++覆辙录》：常见错误23 （改）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X &amp;<span class="keyword">operator</span>%(<span class="keyword">const</span> X&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    X(<span class="keyword">int</span> xx):x(xx)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X &amp;X::<span class="keyword">operator</span>%(<span class="keyword">const</span> X&amp;xx)&#123;</span><br><span class="line">    x = x%xx.x;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X &amp;<span class="keyword">operator</span>%(X&amp;xx,<span class="keyword">int</span> x)&#123;</span><br><span class="line">    xx.x %= x;</span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> X::f()&#123;</span><br><span class="line">    X &amp;anX = *<span class="keyword">this</span>;</span><br><span class="line">    anX % <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">operator</span>%(anX,<span class="number">11</span>); <span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    上面的代码中分别有一个成员函数和一个非成员函数对<code>%</code>进行了重载。我们如果想在<code>x::f()</code>中调用非成员函数版本的重载，初步看上去，<code>anX % 11</code>和<code>operator%(ans,11)</code>应该是等价的。但实际上，在<code>anX % 11</code>这步中，编译器搜索了成员函数和非成员函数，所以能匹配到正确的函数（非成员函数）；而<code>operator%(ans,11)</code>这行代码，编译器只会搜索成员函数，所以会因为找不到匹配的函数而报错。</p>
<h2 id="2-复合赋值与算术运算符的重载方式或顺序"><a href="#2-复合赋值与算术运算符的重载方式或顺序" class="headerlink" title="2.复合赋值与算术运算符的重载方式或顺序"></a>2.复合赋值与算术运算符的重载方式或顺序</h2><p>对于类似（<code>+=</code>）的复合赋值运算符和类似（<code>+</code>）的算术运算符，我们可以有三种重载方式或顺序。</p>
<ol>
<li>重载符合赋值运算符后，用重载的复合赋值运算符重载算术运算符。</li>
<li>重载算术运算符后，用重载的算术运算符重载复合赋值运算符。</li>
<li>独立重载两个运算符。</li>
</ol>
<p>先来看前两个方式，我认为这两种方式的显著优点是实现了<strong>代码重用</strong>。在重载完一个函数后，确实都能让第二个重载的运算符更易读。</p>
<p>《primer c++》 提到，如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。下面将在简单情况下讨论一般情况下这句话的合理性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T(<span class="keyword">int</span> va=<span class="number">0</span>):val(va)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructing "</span> &lt;&lt;val&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    T(<span class="keyword">const</span> T &amp;b)&#123;val=b.val;<span class="built_in">cout</span> &lt;&lt; <span class="string">"copying "</span>&lt;&lt;val&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    T <span class="keyword">operator</span>+(<span class="keyword">const</span> T&amp;)<span class="keyword">const</span>;</span><br><span class="line">    T &amp;<span class="keyword">operator</span>+=(<span class="keyword">const</span> T&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T a = <span class="number">1</span>;</span><br><span class="line">    T b = <span class="number">2</span>;</span><br><span class="line">    T c = a+b;</span><br><span class="line">    a+=b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 对于上面的类和主函数，考察在执行一套<code>+</code>和<code>+=</code>运算后，各种方式一共调用的构造或拷贝构造函数次数。由于<code>Code::Blocks</code>的编译器开启了返回值优化，且两种情况函数<code>return</code>时情况相同，所以下面的结果中，函数<code>return</code>一个临时对象时不会调用拷贝构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种方式</span></span><br><span class="line">T &amp;T::<span class="keyword">operator</span>+=(<span class="keyword">const</span> T&amp;b)&#123;</span><br><span class="line">    val += b.val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T T::<span class="keyword">operator</span>+(<span class="keyword">const</span> T&amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">    T _copy = *<span class="keyword">this</span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    _copy += b;</span><br><span class="line">    <span class="keyword">return</span> _copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">constructing <span class="number">1</span></span><br><span class="line">constructing <span class="number">2</span></span><br><span class="line">copying <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二种方式</span></span><br><span class="line">T T::<span class="keyword">operator</span>+(<span class="keyword">const</span> T&amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">//return T(val+b.val); //调用构造函数，另一种写法</span></span><br><span class="line">    T _copy = *<span class="keyword">this</span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    _copy.val += b.val;</span><br><span class="line">    <span class="keyword">return</span> _copy;</span><br><span class="line">&#125;</span><br><span class="line">T &amp;T::<span class="keyword">operator</span>+=(<span class="keyword">const</span> T&amp;b)&#123;</span><br><span class="line">    *<span class="keyword">this</span> = *<span class="keyword">this</span> + b; <span class="comment">// 调用构造函数或拷贝构造函数</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">constructing <span class="number">1</span></span><br><span class="line">constructing <span class="number">2</span></span><br><span class="line">copying <span class="number">1</span></span><br><span class="line">copying <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>从结果看到，第一种情况确实比第二种节约了步骤成本。进一步分析来看，<code>+</code>算术运算符的重载，无论如何都将调用一次构造函数或拷贝构造函数。所以成本的差异体现在<code>+=</code>的重载方式上，第一种方式由于是直接重载<code>+=</code>，过程中不会调用任何构造函数，所以节约了一次构造成本。</p>
<p>推广到更复杂的情况。如果我们的目的是实现代码的复用及保证一定的代码可读性，第一种方式是首选方式。</p>
<p>然后需要将第三种方式与前面两种进行比较。第一种方式与第三种方式在例子给出的简单情况中，只有一行代码不同，即<code>+</code>的重载中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一种方式：</span><br><span class="line">    _copy += b;</span><br><span class="line"></span><br><span class="line">第三种方式：</span><br><span class="line">    _copy.val += b.val;</span><br></pre></td></tr></table></figure>
<p>显然，第一种方式在调用<code>+=</code>重载的过程中，会有额外的拷贝或移动开销，虽然在编译器包括返回值优化的各种优化下，这种开销减小，但不是不存在。所以在更复杂的情况下，为了保证效率，应该采用第三种方式，将各个运算符独立重载更优。</p>
<p>简单地总结一下：</p>
<p>在简单的模拟情况下，采用第一种方式；而在更复杂的模拟情况下，第三种方式更合适。</p>
<h2 id="3-临时对象与编译器的优化"><a href="#3-临时对象与编译器的优化" class="headerlink" title="3. 临时对象与编译器的优化"></a>3. 临时对象与编译器的优化</h2><p>问题三中我将要讨论两种优化，返回值优化(RVO)和复制省略(copy elision)。</p>
<p>这个问题可能和标题有点脱节，但在类似第二个问题的运算符重载的过程中，不可避免地要<code>return</code>一个临时对象，我们也不可避免地像第二个问题一样要讨论它的开销成本。这个问题也作为第二个问题的补充。</p>
<p>我们考察下面代码（我们可以通过编译时加参数<code>-fno-elide-constructors</code>关闭这两种优化） ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T(<span class="keyword">int</span> va=<span class="number">0</span>):val(va)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructing "</span> &lt;&lt;val&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    T(<span class="keyword">const</span> T &amp;b)&#123;val=b.val;<span class="built_in">cout</span> &lt;&lt; <span class="string">"copying "</span>&lt;&lt;val&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    T <span class="keyword">operator</span>+(<span class="keyword">const</span> T&amp;)<span class="keyword">const</span>;</span><br><span class="line">    T &amp;<span class="keyword">operator</span>+=(<span class="keyword">const</span> T&amp;);</span><br><span class="line">    ~T()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"destructing "</span>&lt;&lt;val&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T T::<span class="keyword">operator</span>+(<span class="keyword">const</span> T&amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">    T _copy = *<span class="keyword">this</span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    _copy += b;</span><br><span class="line">    <span class="keyword">return</span> _copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T a = <span class="number">1</span>;</span><br><span class="line">    T b = <span class="number">2</span>;</span><br><span class="line">    T c = a+b;</span><br><span class="line">   	<span class="built_in">cout</span> &lt;&lt; <span class="string">"over"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">关闭优化以后的输出：</span><br><span class="line">constructing <span class="number">1</span></span><br><span class="line">copying <span class="number">1</span></span><br><span class="line">destructing <span class="number">1</span></span><br><span class="line">constructing <span class="number">2</span></span><br><span class="line">copying <span class="number">2</span></span><br><span class="line">destructing <span class="number">2</span></span><br><span class="line">copying <span class="number">1</span></span><br><span class="line">copying <span class="number">3</span></span><br><span class="line">destructing <span class="number">3</span></span><br><span class="line">copying <span class="number">3</span></span><br><span class="line">destructing <span class="number">3</span></span><br><span class="line">over</span><br><span class="line">destructing <span class="number">3</span></span><br><span class="line">destructing <span class="number">2</span></span><br><span class="line">destructing <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>先看输出的后半段，在编译器没有进行返回值优化的情况下，我们学过，<code>return _copy</code>时，因为<code>_copy</code>是一个临时对象，会先调用拷贝构造函数用<code>_copy</code>拷贝构造出另一个临时对象，这个临时对象时没有名字的，我们不妨假设为<code>copy1</code>,然后<code>a.operator+()</code>函数退出，<code>_copy</code>被析构，于是总体上说，重载函数返回的是一个没有名字的临时对象。由结果来看，<strong>这个临时对象在完成c的拷贝构造后就析构了</strong>；从拷贝构造函数的参数讲，这个临时对象是有地址的。</p>
<p>更具体地说，在不开启返回值优化时，函数被编译器处理后的（伪）代码大概如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T T::<span class="keyword">operator</span>+(T &amp;copy1,<span class="keyword">const</span> T&amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">    T _copy(*<span class="keyword">this</span>); <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    _copy += b;</span><br><span class="line">    copy1.T::T(_copy); <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    _copy.T::~T();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会引入参数<code>T &amp;copy1</code>,该参数用来引用函数要返回的临时对象，更进一步可以看到<code>copy1</code>的<strong>内存地址</strong>和<strong>对应类型</strong>在定义前就已经确定。</p>
<p>所以没有优化时后半段输出的解释如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">copying <span class="number">1</span> </span><br><span class="line">copying <span class="number">3</span>       <span class="comment">//copy1被拷贝构造</span></span><br><span class="line">destructing <span class="number">3</span>   <span class="comment">//_copy被析构</span></span><br><span class="line">copying <span class="number">3</span>       <span class="comment">//c被拷贝构造</span></span><br><span class="line">destructing <span class="number">3</span>	<span class="comment">//copy1被析构</span></span><br><span class="line">over</span><br><span class="line">destructing <span class="number">3</span>   <span class="comment">//c被析构</span></span><br><span class="line">destructing <span class="number">2</span>	<span class="comment">//b被析构</span></span><br><span class="line">destructing <span class="number">1</span>	<span class="comment">//a被析构</span></span><br></pre></td></tr></table></figure>
<p>而开启返回值优化后，后半段输出如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">开启优化时输出：</span><br><span class="line">copying <span class="number">1</span></span><br><span class="line">over</span><br><span class="line">destructing <span class="number">3</span></span><br><span class="line">destructing <span class="number">2</span></span><br><span class="line">destructing <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>要具体解释要先理解返回值优化的原理。</p>
<p><strong>返回值优化(RVO)</strong>发生在当编译器识别出了 <code>return</code>后的返回对象类型和函数的返回对象的类型一致时。此时编译器会直接将而这关联在一起，或者说是将<code>return</code>后的返回对象替换为函数的返回对象，这里函数的返回对象是匿名对象，也就是我们这里的<code>copy1</code>。</p>
<p>优化后编译器处理后的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T T::<span class="keyword">operator</span>+(T &amp;copy1,<span class="keyword">const</span> T&amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">    copy1.T::T(*<span class="keyword">this</span>); <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    copy1 += b;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但此时仍不能解释开启优化后的输出。在查阅维基百科时了解到，在不同的编译器版本或编译设置下，RVO的程度可能不同，也可能是用了其它类型的优化。而通过更深的查找资料，我<strong>猜想</strong>这里使用了<code>copy elision</code>优化。</p>
<p>此时将引入<code>copy elision</code>优化。</p>
<p><code>copy elision</code>优化是指当用一个临时<code>class</code>对象去初始化同类型的对象时，复制初始化通常优化为直接初始化。</p>
<p>我没有查到具体怎么实现优化的，但<strong>可能</strong>是下面的方式。</p>
<p><code>return</code>后的返回对象会直接与被初始化的对象关联，或者说<code>return</code>后的返回对象被直接替换成了要初始化的对象，这里是<code>c</code>.</p>
<p>所以最终优化后函数(伪)代码应该如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T T::<span class="keyword">operator</span>+(T &amp;c,<span class="keyword">const</span> T&amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">    c.T::T(*<span class="keyword">this</span>); <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    c += b;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以优化开启后后半段输出的解释如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">开启优化时输出：</span><br><span class="line">copying <span class="number">1</span>       <span class="comment">//c被拷贝构造</span></span><br><span class="line">over</span><br><span class="line">destructing <span class="number">3</span>	<span class="comment">//c被析构</span></span><br><span class="line">destructing <span class="number">2</span>	</span><br><span class="line">destructing <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<p>为了验证RVO，我也做了非初始化情况的验证。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">将</span><br><span class="line">T c = a+b;</span><br><span class="line">改为</span><br><span class="line">T c;</span><br><span class="line">c = a+b;</span><br><span class="line"></span><br><span class="line">关闭返回值优化后的输出:</span><br><span class="line">constructing <span class="number">1</span></span><br><span class="line">copying <span class="number">1</span></span><br><span class="line">destructing <span class="number">1</span></span><br><span class="line">constructing <span class="number">2</span></span><br><span class="line">copying <span class="number">2</span></span><br><span class="line">destructing <span class="number">2</span></span><br><span class="line">constructing <span class="number">0</span></span><br><span class="line">copying <span class="number">1</span></span><br><span class="line">copying <span class="number">3</span></span><br><span class="line">destructing <span class="number">3</span></span><br><span class="line">destructing <span class="number">3</span></span><br><span class="line">over</span><br><span class="line">destructing <span class="number">3</span></span><br><span class="line">destructing <span class="number">2</span></span><br><span class="line">destructing <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">开启返回值优化时:</span><br><span class="line">constructing <span class="number">1</span></span><br><span class="line">constructing <span class="number">2</span></span><br><span class="line">constructing <span class="number">0</span></span><br><span class="line">copying <span class="number">1</span></span><br><span class="line">destructing <span class="number">3</span></span><br><span class="line">over</span><br><span class="line">destructing <span class="number">3</span></span><br><span class="line">destructing <span class="number">2</span></span><br><span class="line">destructing <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>此时的后半段输出与返回值优化的伪代码完全应证，即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructing <span class="number">0</span> <span class="comment">//c被构造</span></span><br><span class="line">copying <span class="number">1</span>      <span class="comment">//copy1被构造</span></span><br><span class="line">destructing <span class="number">3</span>  <span class="comment">//在复制赋值后copy1被析构</span></span><br><span class="line">over</span><br><span class="line">destructing <span class="number">3</span>  <span class="comment">//c被析构</span></span><br><span class="line">destructing <span class="number">2</span></span><br><span class="line">destructing <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<p>而凭借<code>copy elision</code>的优化原理，我们能解释前半段代码。即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">优化前：</span><br><span class="line">constructing <span class="number">1</span></span><br><span class="line">copying <span class="number">1</span></span><br><span class="line">destructing <span class="number">1</span></span><br><span class="line">constructing <span class="number">2</span></span><br><span class="line">copying <span class="number">2</span></span><br><span class="line">destructing <span class="number">2</span></span><br><span class="line"></span><br><span class="line">优化后：</span><br><span class="line">constructing <span class="number">1</span></span><br><span class="line">constructing <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><code>T a = 1;</code>和 <code>T b = 2;</code>中。1和2被转换为临时的类型为<code>T</code>的对象，触发<code>copy elision</code>优化，拷贝构造被优化为直接构造。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>c++是一个历史悠久的语言，要掌握c++需要不断地练习与查阅，最好是官方文档。国内的博客在近些年来内容水分严重，不尽如人意。在查找资料的过程中，感觉最有用的是维基百科，官方文档和类似《primer c++》之类的书籍，但因为自己查找资料能力的不足，过分相信博客内容，在过程中走了很多弯路，望引以为戒。</p>
<hr>
<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p>[1]Stanley B. Lippman, Josée Lajoie, Barbara E. Moo. C++ Primer,5E[M]. 北京：电子工业出版社，2013</p>
<p>[2]Stephen C. Dewhurst. C++覆辙录[M]. 北京：人民邮电出版社，2016</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/04/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wexsub">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wexsub's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/04/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-04 11:29:00 / 修改时间：08:19:44" itemprop="dateCreated datePublished" datetime="2020-01-04T11:29:00+08:00">2020-01-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/杂/" itemprop="url" rel="index">
                    <span itemprop="name">杂</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        我的博客又又又重启了，看下这下能坚持多久吧。</p>
<p>blog building tips:</p>
<ol>
<li>注意CNAME的创建</li>
<li>现在  <code>.io</code> 文件夹还不知道咋用</li>
<li><p>/layout/_partial/footer.ejs 里面删除了busuanzi，写法是</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_pv"</span>&gt;</span>不蒜子告之   阁下是第<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>个访客<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除评论功能，把所有gitment的东西全删了，最隐蔽的是<code>article.ejs</code>里，找了好久。</p>
</li>
<li>更换图片，头标</li>
<li>网站模板（antiquity)里有些莫名奇妙的东西。</li>
<li>最后还是用回了next。。。 要找一个又好看又支持latex的模板真的难，有时间自己<del>抄一个</del>写一个吧。next好大</li>
<li>语言不知道为什么变成了德语，没事，把德语删掉就好了</li>
<li>先这样吧，以后有时间再美化。</li>
</ol>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wexsub</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wexsub</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
